<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP 上篇：可靠数据传输原理</title>
    <link href="/2023/03/12/tcp/"/>
    <url>/2023/03/12/tcp/</url>
    
    <content type="html"><![CDATA[<p>数据在信道传输的过程中，要考虑两种情况：</p><ul><li>比特差错：分组能到达，但其中的比特可能受损；</li><li>丢包：分组可能被整个丢失，完全不能到达；</li></ul><p>以下讨论中，我们暂且假设分组在发送方和接收方的信道中不会被重新排序，即发送方以 1，2 的顺序发包，接收方就不会在收到 2 之后才收到 1（如果先收到 2 说明 1 一定发生了丢包）。</p><h1 id="针对比特差错的考虑"><a href="#针对比特差错的考虑" class="headerlink" title="针对比特差错的考虑"></a>针对比特差错的考虑</h1><p>先考虑信道只出现比特差错的情况。为处理这种情况，引入 ARQ（Automatic Repeat reQuest）协议的概念，即发送方根据接收方的 ACK 和 NAK 反馈信息判断是否需要重传分组。ARQ 需要三种功能支持：</p><ol><li>差错检测：通过差错检测和纠错技术判断分组的比特是否受损；</li><li>接收方反馈：接收方检查分组，未受损恢复 ACK，反之回复 NAK；</li><li>重传：接收方收到 NAK 或是<strong>受损的反馈分组</strong>都选择重传该分组；</li></ol><p>由于任何追加信息的传输都要考虑受损，当 ACK 或 NAK 受损时，选择直接重传分组是明智的选择，但接收方因此需要判断自己收到的分组是否是上一个的重传。为此，给每个分组标上序号来辅助判断。在处理好当前分组再考虑下一个的“单周期”模式中，序号对 2 取模，只通过 0，1 判断是否为上一个包的重复即可。</p><p>事实上，我们可以让接收方在收到受损数据包时不回复 NAK，而是回复对上一个包的 ACK，这样也能告知发送方应当重传受损的数据包。于是，我们实现了一个无 NAK 的可靠数据传输协议。</p><h1 id="针对丢包的考虑"><a href="#针对丢包的考虑" class="headerlink" title="针对丢包的考虑"></a>针对丢包的考虑</h1><p>如果信道还会发生丢包，那么上述协议就会出现某一方一直等待已丢失分组的情况。</p><p>如果让发送方来负责丢包的检测和处理，重传就是一种万能灵药。发送方可以在每一个数据包发送后设定一个定时器，在规定时间内没有收到 ACK 则直接选择重传。</p><p>接收方在收到重复的数据包之后，只需要照常回复 ACK 即可。</p><h1 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h1><p>在上面的讨论中，我们采用的思路是“处理完当前的包再发送下一个”。这种模式会导致 RTT 远大于将数据送入链路的时间，使得信道的利用率非常低下。因此，我们引入流水线的思想，即一次性写入多个分组，并为每个分组处理丢失、损失和延时过大等情况。</p><h2 id="回退-N-步（GBN）"><a href="#回退-N-步（GBN）" class="headerlink" title="回退 N 步（GBN）"></a>回退 N 步（GBN）</h2><p>在这个协议中，我们给发送方引入一个长为 N 的环状区间，发送报文的序号就在这个区间之中。区间中有一分界线，左侧是已发送但未收到 ACK 的序号，右侧是未使用的序号。</p><p>当上层需要发送报文时，若分界线右侧仍有未使用序号，则用该序号发送报文；若发送方收到 ACK，则区间应向右滑动一次。</p><blockquote><p>基于前面的底层信道有序假设，我们可以让接收方在收到预期之外的数据包时重复对上个正确接收包的 ACK 并丢失该数据包，所以发送方可以保证窗口滑动过程中包的 ACK 是按序收到的。</p></blockquote><p>发送方仍然保持一个定时器，这个定时器会跟踪当前区间最左侧未收到 ACK 的已发送包；若该包已超时，考虑到接收方会把后续的包丢掉，所以发送方会将窗口分界线左侧的包全部重发，即“回退 N 步”。</p><h2 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h2><p>一个包的丢失或差错导致所有包的重复传输代价有些高，所以我们基于 GBN 的滑动窗口模型提出选择重传的协议。</p><p>在这个协议中，接收方也引入一个滑动窗口用于统计包的接收情况。此时接收方不会丢弃失序到达的数据包，而是在窗口中将其缓存，直到窗口左侧有连续的有序分组再将它们统一交付（并滑动窗口）；现在发送方会为每个包设置一个定时器，并分别判断它们是否需要重传。</p><p>在这种情况下，ACK 不是有序到达的，接收方和发送方的窗口滑动也需要协调。假如接收方收到了窗口左侧的数据包，说明之前发送的 ACK 已经丢失，发送方选择了重传，这时候接收方必须重新发送 ACK 才能保证发送方的窗口能正常向右滑动。</p><p>另一个问题有关滑动窗口和序号空间的大小。考虑序号空间为 8，窗口大小为 5：当发送方和接收方窗口均处于 $2,3,4,5,6$ 时，发送方连续发送这五个序号的包，在极端情况下，接收方回复的 5 个 ACK 全部丢失，此时的窗口变为：</p><ul><li>发送方：$2,3,4,5,6$</li><li>接收方：$7,0,1,2,3$</li></ul><p>现在发送方把序号 2 重传时，接收方会认为这是一个新的包，从而造成误解。因此，SR 协议接收方的<strong>窗口大小必须小于等于序号空间的一半</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>eBPF 原理与应用纪要</title>
    <link href="/2023/03/10/eBPF_summary/"/>
    <url>/2023/03/10/eBPF_summary/</url>
    
    <content type="html"><![CDATA[<p>网上有很多关于 eBPF 的资料，但是大多数还是“内核中的虚拟机，挂载到 kprobes”之类的车轱辘话，并没有解决初学 eBPF 的几个疑点。在这里记录一下 eBPF 出现的逻辑、eBPF 相较于 perf 等内核监测工具的区别以及当前 eBPF 前端常用的挂载流程这三个问题。</p><h1 id="eBPF-概述"><a href="#eBPF-概述" class="headerlink" title="eBPF 概述"></a>eBPF 概述</h1><p>eBPF（extended Berkeley Packet Filter）在本质上迎合了定制内核功能的需求。内核能够获取系统运行的第一手数据，而用户态进程对数据的处理则是高度定制化的。如果将大量数据从内核拷贝到用户空间由进程处理，会带来很大开销；而用户对数据的处理需求又无穷无尽，不可能由内核提供稳定的接口来满足。我们可能会想到根据自己的需求修改内核代码，定制专门的内核模块；然而，每次修改后都需要重新编译、分发、部署内核的代价是巨大的，而且对内核的修改容易带来安全和稳定性方面的问题。</p><p>在内核中，eBPF 扮演的角色实质上等同于浏览器中的 js——一个在线的通用执行引擎。在 eBPF 的帮助下，我们可以在用户态编写代码，并将编译后得到的 BPF 字节码注入内核，挂载到指定的位置，并在触发后由内核提供的 BPF 虚拟机沙箱运行。</p><div class="note note-info">            <p>实际上在内核中植入一个通用执行引擎的最大好处应该就是大大减少了数据的拷贝量，毕竟在用户态编程更自由。</p>          </div><h1 id="kprobes-和-tracepoint"><a href="#kprobes-和-tracepoint" class="headerlink" title="kprobes 和 tracepoint"></a>kprobes 和 tracepoint</h1><p>就像 debugger 可以给程序的任意指令地址插入断点，插桩技术可以跟踪运行中的程序（或内核）并记录相关函数的信息、执行用户定义的操作。其中，kprobes（和 uprobes）为动态插桩，可以挂载到任意函数的入口和出口；tracepoint（和 USDT）是被硬编码到软件代码中静态插桩点，由软件开发者维护。</p><p>显然，kprobes 更为灵活，但软件版本的修改可能导致对目标函数挂载的失效；tracepoint 由开发者维护，数量有限但更为稳定。因此，当条件允许时应优先使用 tracepoint，而非 kprobes。</p><p>使用 kprobes 主要有三种接口：</p><ol><li>利用 kprobes api 编写内核模块，然后加载该模块；</li><li>基于 ftrace，向特定文件写入字符串来开启 kprobes；</li><li>利用 <code>perf_event_open</code> 系统调用，基于 <code>perf_event</code> 机制；</li></ol><p>其中第三种方式是当前 BPF 前端常用的挂载方式。</p><div class="note note-info">            <p>kprobes 是通过在线修改内核指令段实现的，即保存待插桩地址的指令，将其覆盖为中断或 jmp 指令，并执行 kprobe 处理函数。当使用 uprobes 对用户态库函数（如 <code>malloc</code> 或是 <code>gethostbyname</code>）进行追踪时，现有的方案还需要通过中断等技术进行内核的往返。</p>          </div><h1 id="ftrace-和-perf"><a href="#ftrace-和-perf" class="headerlink" title="ftrace 和 perf"></a>ftrace 和 perf</h1><p>在 eBPF 之前，基于 kprobes 和 tracepoint 的监测工具已经有很多。其中，有利用内核 tracepoint 的 ftrace，还有基于内核的 <code>perf_event</code> 而能够对 tracepoint、kprobes/uprobes 和 PMU 等多种事件进行数据统计的 perf, 以及基于自己开发的内核模块的 SystemTap 等等。</p><p>然而，尽管有着如此多的性能监测工具，eBPF 却是唯一一个能够<strong>在内核态执行用户自定义逻辑</strong>（如 perf 在内核态只有简单计数功能），且稳定置于 Linux 内核的结构（如 SystemTap 自行开发的内核模块在 REHL 发行版之外的 Linux 上被证明不太可靠）。</p><h1 id="eBPF-前端"><a href="#eBPF-前端" class="headerlink" title="eBPF 前端"></a>eBPF 前端</h1><p>目前 eBPF 最广泛使用的前端应当是 bcc 和 bpftrace，这二者都提供了 BPF 编程的高级语言。这里我们并不关注编程的细节，而是大致分析 BPF 程序生效的流程。</p><p>我们往往希望基于事件编写 BPF 程序，而事件源可以是 kprobes、tracepoint 等。在 BPF 的早期，它只用来进行数据包的过滤，对多种事件源的支持是后来加入的特性。现在常用的前端往往基于这样一个流程实现 BPF 编程（以基于 kprobes 的 BPF 程序为例）：</p><ol><li>编写 BPF 程序，并编译为 BPF 字节码；</li><li>通过命令为 <code>BPF_PROG_LOAD</code> 的 <code>bpf</code> 系统调用，将 BPF 程序交给内核，由内核负责合法性检验和可能的 JIT 编译等工作，最终获取一个与该 BPF 程序相关联的文件描述符；</li><li>通过 <code>perf_event_open</code> 系统调用获取一个 kprobes 类型的 <code>perf_event</code> 相关联的文件描述符；</li><li>通过 <code>ioctl</code> 函数将 BPF 程序的文件描述符关联到 <code>perf_event</code> 的文件描述符上；</li></ol><p>总结：基于 <code>bpf</code> 系统调用将 BPF 程序注入内核，然后基于 <code>perf_event_open</code> 系统调用和 <code>ioctl</code> 将 BPF 程序挂载到 kprobes 类型的 <code>perf_event</code>。</p><div class="note note-info">            <p>将 BPF 程序挂载到 kprobes 上只是 Linux perf 子系统中一个小小的功能。然而，perf 提供的其他功能并没有 BPF 独有的内核可编程性。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Kernel</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.S081 2020 xv6 labs</title>
    <link href="/2023/02/28/mit6s081_2020_labs/"/>
    <url>/2023/02/28/mit6s081_2020_labs/</url>
    
    <content type="html"><![CDATA[<p>20 年的 xv6 实验和 21 年主要有两个不同：</p><ul><li>20 年多了一个 <code>sbrk</code> 的 Lazy allocation；</li><li>20 年的页表实验和 21 年有很大不同，难度较高；</li></ul><div class="note note-success">            <p>代码：<a href="https://github.com/CH3CHOHCH3/xv6-labs-2020">https://github.com/CH3CHOHCH3/xv6-labs-2020</a></p><p>问答题直接看对应的 answers-lab.txt 即可。</p>          </div><h1 id="Lab3-Page-tables"><a href="#Lab3-Page-tables" class="headerlink" title="Lab3 Page tables"></a>Lab3 Page tables</h1><p>xv6 的用户态和内核态使用不同的页表：每个进程有自己的进程页表，内核使用一个全局内核页表。当内核想要从进程地址空间获取参数，或是向其中写入内容时，xv6 采用的做法是利用内核数据的恒等映射，软件模拟 MMU 查询进程虚拟地址对应的物理地址。这个实验的主要目标是为每个进程实现自己的内核页表，切换进程时顺带切换内核页表，然后内核就能直接访问用户地址空间而不需要多次查询页表。</p><p>注意，内核态和用户态之所以能共用页表，是因为 xv6 默认每个进程的虚拟地址空间从 0 开始依次是代码段、数据段、栈保护页、栈、堆，在虚拟地址空间最高处映射了 TRAMPOLINE 和 TRAPFRAME 两个页；而内核页表原本映射的最低处是 CLINT 对应的 0x2000000，但这个地址用来在机器态处理时钟，所以用户的内核页表完全没必要映射，最低地址变为 PLIC，最高地址则是 TRAMPOLINE 和每个进程的内核栈及保护页（内核不需要映射 TRAMPFRAME 页，直接访问 <code>p-&gt;trapframe</code> 即可）。</p><div style="text-align:center"><img src="/img/mit6s081_2020_labs/kernel_vaddress.png"></div><p>也就是说，为了满足用户态和内核态共用页表，用户进程占用的最高地址空间不能超过 PLIC，而进程需要用到的 TRAMPFRAME 则保存在用户页表中（其实可以处理一下 TRAPFRAME 和进程内核栈的冲突，每个进程的内核和用户态统一用一张页表，在陷入时甚至不需要切换页表）。</p><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>这个任务和 <a href="https://ch3chohch3.github.io/2023/02/22/mit6s081_2021_labs/#Print-a-page-table">21 年任务二</a>没有任何区别。</p><h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><p>这个任务即为每个进程实现自己的内核页表，并处理好页表的切换和释放等细节。</p><p>指导书的意见是给每个进程创建一份页表，然后参考 <code>kvminit</code> 把该映射的内容映射进去。事实上，我们知道每个进程用户态虚拟地址空间最多能用的大小只有 0xC000000，而三级页表中一个一级页表项能对应的地址空间大小为 0x40000000，所以我们只需要在 <code>allocproc</code> 中用一个页复制全局内核页表的 1-511 项，然后单独映射第 0 项（<a href="https://github.com/CH3CHOHCH3/xv6-labs-2020/commit/483cb5b9d8bc7e3704da0ab6e26f90bbcca065ce#diff-f06ba4e6ae5b13cb787bad05af2c231bcf826410f25bfd78b18774115f0d20a8R125">代码实现</a>）</p><p>而在 <code>freeproc</code> 中释放进程内核页表时，也只需要递归释放其第一项对应的页表项（物理页会被 <code>proc_freepagetable</code> 回收）。</p><p>最后在 <code>scheduler</code> 中切换进程内核页表即可。</p><h2 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify copyin/copyinstr</h2><p>这个任务完成对 <code>copyin</code> 和 <code>copyinstr</code> 的最终简化。实验框架已经写好了这两个函数，只需要把原本的函数替换。我们需要做的是把进程的用户虚拟地址空间映射到进程自己的内核页表。这里面有两个问题：</p><ol><li>怎么映射：<a href="https://github.com/CH3CHOHCH3/xv6-labs-2020/commit/e7dbec8242cc819b6d7d19d7ac555b9d6c1793c8#diff-6eeb81e8dc9689c28a91a11fb716202a1efd81665e5f3586082b2ab82a7c8a3dR478">代码</a>胜千言；</li><li>何时映射：进程最初创建的时候要完成映射，这里主要是 <code>fork</code> 和 <code>userinit</code> 两个函数；进程修改页表项的时候，要修改映射，这里主要是 <code>sbrk</code> 和 <code>exec</code>，具体映射时机和参数可以参考同一个 commit；</li></ol><p>解决这两个问题，也就完成了本次实验。</p><h1 id="Lab5-Lazy-allocation"><a href="#Lab5-Lazy-allocation" class="headerlink" title="Lab5 Lazy allocation"></a>Lab5 Lazy allocation</h1><p>本实验要求为 <code>sbrk</code> 系统调用增加的页面实现 Lazy 分配。众所周知，<code>sbrk</code> 会增加进程堆的大小，内核为其分配物理页并完成内存映射；而所谓 lazy 分配即只增加 <code>p-&gt;sz</code> 的大小，而物理页的分配延迟到缺页中断处理程序进行。实现这个功能比想象中更复杂一些，因为“本应存在的虚拟内存”这一概念会在很多地方带来问题。</p><p>首先，我们修改 <code>sys_sbrk</code> 的实现：</p><ul><li>对于正参数，只增加 <code>p-&gt;sz</code> 并返回；</li><li>对于负参数，参考 <code>growproc</code>，直接调用 <code>uvmdealloc</code>；</li></ul><p>接下来，在 <code>usertrap</code> 中增加缺页的中断处理代码。这里需要判断是否是 lazy 分配导致的缺页，具体来说，发生缺页的虚拟地址应当满足：</p><ul><li>不超过 <code>p-&gt;sz</code>；</li><li>不低于进程的用户栈；</li></ul><p>可以参考 xv6 book 中关于进程虚拟内存分布的图：</p><div style="text-align:center"><img src="/img/mit6s081_2020_labs/user_vaddress.png"></div><p>除此之外，未映射的虚拟地址会导致 <code>uvmcopy</code> 和 <code>uvmunmap</code> 报错，这里可以直接把 <code>panic</code> 改为 <code>continue</code>；而且内核通过 <code>copyin</code>/<code>copyout</code> 访问未分配的虚拟地址也会报错，这两个函数依然需要判断是否是 lazy 分配导致的缺页并为之分配物理页、完成映射。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.S081 2021 xv6 labs</title>
    <link href="/2023/02/22/mit6s081_2021_labs/"/>
    <url>/2023/02/22/mit6s081_2021_labs/</url>
    
    <content type="html"><![CDATA[<p>汇总一下 2021 年度 MIT 6.S081 的 10 个实验。</p><div class="note note-success">            <p>代码：<a href="https://github.com/CH3CHOHCH3/xv6-labs-2021">https://github.com/CH3CHOHCH3/xv6-labs-2021</a></p><p>问答题直接看对应的 answers-lab.txt 即可。</p>          </div><h1 id="Lab1-Utilities"><a href="#Lab1-Utilities" class="headerlink" title="Lab1 Utilities"></a>Lab1 Utilities</h1><p>通过系统调用实现五个功能。</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>用 <code>atoi</code> 把字符串转为数字，直接调用 <code>sleep</code> 即可。</p><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>注意管道是半双工通信（所以本题需要两个管道），主要用于父子进程通信：</p><ul><li>读进程要及时关闭管道写端，防止所有写进程退出后 <code>read</code> 不能立即返回 0;</li><li>写进程要及时关闭管道读端，防止所有读进程退出后 <code>write</code> 不能触发 SIGPIPE 信号;</li></ul><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>本题有两个关键点。</p><ol><li>并发：从父进程读到数字应立即筛选并写给子进程，读完所有数字再写是错的；</li><li>避免递归：<code>fork</code> 会复制父进程的栈空间，递归的写法会让栈越来越小。</li></ol><p>综上，可以使用 <code>goto</code> 直接让子进程跳转到 <code>fork</code> 之前，在这个框架下进行素数筛。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>参考 <code>user/ls.c</code> 中递归目录的写法即可，注意不要递归搜索 <code>.</code> 和 <code>..</code>。</p><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>题意是读标准输入文件，每读完一行把该行内容作为附加参数，通过 <code>fork</code> + <code>exec</code> 传给目标程序，执行完之后读下一行。</p><p>例如 <code>echo &quot;1\n2&quot; | xargs echo hello</code> 等价于顺序执行 <code>echo hello 1</code> 和 <code>echo hello 2</code>。</p><h1 id="Lab2-System-Calls"><a href="#Lab2-System-Calls" class="headerlink" title="Lab2 System Calls"></a>Lab2 System Calls</h1><p>给 xv6 增加两个系统调用。需要知道 xv6 系统调用的用户侧接口是 <code>user/usys.pl</code> 实现的汇编代码（核心指令是 <code>ecall</code>），内核的处理是通过 <code>kernel/trap.c</code> 中调用的 <code>syscall</code> 函数（位于 <code>kernel/syscall.c</code>）, 而该函数通过 <code>a7</code> 寄存器（值位于 <code>trapframe</code>）获取系统调用号，并在一个函数指针数组中找到对应的处理函数。</p><h2 id="tracing"><a href="#tracing" class="headerlink" title="tracing"></a>tracing</h2><p>这个系统调用把一个 <code>int</code> 型 32 位掩码作为参数，要求内核输出该进程及其子进程使用的系统调用号对应掩码位为 1 的所有系统调用名。</p><p>可以在 <code>proc</code> 结构体中定义一个默认为 0 的 mask 成员，<code>trace</code> 系统调用的功能就是设定 <code>proc-&gt;mask</code>，在 <code>syscall</code> 函数中顺手检查掩码并输出系统调用的名字即可（记得在 <code>fork</code> 中传递 mask 的值）。</p><h2 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h2><p>这个系统调用以一个 <code>sysinfo</code> 指针为参数，希望内核将当前的空闲内存（以 byte 为单位）和所有处于非 UNUSED 状态的进程数写到目标地址。本题有三个关键点：</p><ol><li><strong>获取空闲内存</strong>：可以遍历 <code>kernel/kalloc.c</code> 中记录所有空闲页物理地址的链表 <code>freelist</code>，乘以 PGSIZE 即为答案；</li><li><strong>获取非 UNUSED 状态进程数</strong>：可以遍历 <code>kernel/proc.c</code> 中的 <code>proc</code> 数组，通过 <code>p-&gt;state</code> 判断进程状态并计数；</li><li><strong>获取参数并写回答案</strong>：获取参数通过 <code>argaddr</code> 实现（本质上还是读寄存器 <code>a0</code> - <code>a5</code>），写回答案通过 <code>copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</code> 实现，其作用为将 <code>src</code> 处的 <code>len</code> 字节内容复制到 <code>pagetable</code> 根页表下的 <code>dstva</code> 处。</li></ol><h1 id="Lab3-Page-Tables"><a href="#Lab3-Page-Tables" class="headerlink" title="Lab3 Page Tables"></a>Lab3 Page Tables</h1><p>2021 的页表实验比 2020 简单一些。</p><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>题目要求把进程 <code>pid</code> 写入一个单独的物理页，然后把进程地址空间的一个只读页映射到该物理页，进程就可以不通过系统调用直接读取进程号。</p><p>这个题已经在 <code>kernel/memlayout.h</code> 中定义好了 <code>USYSCALL</code> 这个虚拟地址，我们可以直接参考 <code>kernel/proc.c</code> 中对 <code>trampframe</code> 页的处理：</p><ol><li>在 <code>allocproc</code> 中用 <code>kalloc</code> 分配物理页，在 <code>proc_pagetable</code> 中完成映射；</li><li>在 <code>freeproc</code> 中用 <code>kfree</code> 释放物理页，在 <code>proc_freepagetable</code> 中清空页表；</li></ol><p>这样进程就可以直接访问 <code>USYSCALL</code> 这个虚拟地址来读取进程号了。</p><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>打印 <code>init</code> 进程的页表，直接参考 <code>freewalk</code> 怎么递归处理三级页表即可。</p><p>注意 <code>freewalk</code> 的功能是清空页表自身占用的物理页，它要求叶页表项的映射必须事先已经被 <code>uvmunmap</code> 清空；而 <code>vmprint</code> 不需要考虑这个问题，遇到非 0 的叶页表项直接输出即可。</p><h2 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h2><p>实现系统调用 <code>pgaccess(void *base, int len, void *mask)</code>，用于统计从起始虚拟地址起若干连续页面的访问情况。参数含义：</p><ol><li><code>base</code>：表示检测起点的虚拟地址；</li><li><code>len</code>：表示检测页的数目；</li><li><code>mask</code>：表示以掩码形式返回结果的地址；</li></ol><p>这个题实现功能并不难，直接遍历所有页，用 <code>walk</code> 找到每个虚拟地址的 pte 然后看 PTE_A 即可（记得看完要置0）。一个需要思考的地方在于，不能预先知道统计多少页；所以我直接用一个 <code>char</code> 存答案，每统计 8 个页面写回一个 byte，熟悉指针的话并不难实现。</p><h1 id="Lab4-Traps"><a href="#Lab4-Traps" class="headerlink" title="Lab4 Traps"></a>Lab4 Traps</h1><p>异常控制流的内容，核心机制就是 <code>stvec</code> 寄存器存着 <code>kernel/trampoline.S</code> 的 <code>uservec</code> 函数地址，用户态要陷入或者 CPU 接收到中断就保存 PC，然后跳转到这个用户态中断向量处，它会负责保存现场然后跳转到 <code>kernel/trap.c</code> 的 <code>usertrap</code> 处，然后 <code>usertrap</code> 就根据 <code>scause</code> 寄存器进行处理。</p><p>xv6 的中断处理流程和王道操作系统给的一般流程基本一致：</p><ul><li>硬件完成：关中断$\rightarrow$保存断点$\rightarrow$中断服务程序寻址；</li><li>中断程序完成：保存现场和屏蔽字$\rightarrow$开中断$\rightarrow$中断服务$\rightarrow$关中断$\rightarrow$恢复现场和屏蔽字$\rightarrow$开中断$\rightarrow$返回。</li></ul><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><p>一些简单的 QA，值得一提的就是最后一问 <code>printf(&quot;x=%d y=%d&quot;, 3);</code> 的输出。只要知道 RISC-V 传参是通过 <code>a0</code>-<code>a7</code> 寄存器传参就知道最终 y 的值应该是 <code>a2</code> 寄存器的值。</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>在 <code>kernel/printf.c</code> 里实现一个函数来输出目前栈中的函数调用链。实现思路就是先用内联汇编写一个函数 <code>r_fp</code> 从 <code>s0</code> 寄存器读取当前函数的栈帧地址 <code>fp</code>，然后根据 xv6 的栈帧结构，<code>fp - 8</code> 就是函数返回地址（要输出的内容），<code>fp - 16</code> 就是上一个函数栈帧的地址，一直迭代到 <code>fp</code> 所在页的最高地址（xv6 栈从高到低生长）。</p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>真正用到 trap 机制的题目，要求实现一个系统调用 <code>sigalarm(int ticks, void (*handler)())</code>，进程调用后每经过 <code>ticks</code> 个时钟中断就跳转到 <code>handler</code>，执行完之后再返回跳转前的位置。</p><p>这个题目的第一个关键点在于知道 <code>kernel/trap.c</code> 的 <code>usertrap</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield()<br></code></pre></td></tr></table></figure><p>是处理时钟中断的内容，那么我们给每个进程增加 <code>ticks</code>、<code>interval</code> 这些 field 用于判断何时应该调用 <code>handler</code> 即可。</p><p>第二个关键点是如何实现 <code>handler</code> 的跳转和返回。前面提到硬件在跳转时负责保存 PC，保存的位置就是 <code>sepc</code> 寄存器；而 <code>usertrap</code> 函数会把 <code>sepc</code> 的值写到进程的 <code>trapframe-&gt;epc</code> 中，所以我们直接修改 <code>p-&gt;trapframe-&gt;epc</code> 就能实现返回用户态时跳转到 <code>handler</code>。</p><p>为了实现从 <code>handler</code> 中返回，题目提供了一种机制：即每个 <code>handler</code> 都需要在最后调用系统调用 <code>sigreturn</code>。基于此，我们只需要把修改前的 <code>trapframe</code> 做一个备份（直接存在 <code>p-&gt;trapframe</code> 所在页即可，因为本来他就只占了 280 多 byte），然后在 <code>sigreturn</code> 中把备份的 <code>trapframe</code> 覆写回来。</p><h1 id="Lab5-Copy-on-Write-Fork"><a href="#Lab5-Copy-on-Write-Fork" class="headerlink" title="Lab5 Copy-on-Write Fork"></a>Lab5 Copy-on-Write Fork</h1><p>实验五要求实现写时复制的 fork。为了实现这个机制，要完成以下几个工作：</p><ol><li>使用 RISC-V PTE 的 RSW 位为 cow 造成的缺页作标识；</li><li>为每个物理页记录一个引用数（可以直接存到数组中），目的是防止出现类似父进程退出之后子进程的物理页也被释放的情况；</li><li>在 <code>fork</code> 调用的 <code>uvmcopy</code> 中，不再为子进程分配新的物理页并复制父进程的物理页，而是直接将子进程的虚拟地址映射到父进程的物理页，并更新 PTE_W，PTE_COW，引用数；</li><li>在 <code>usertrap</code> 中，<code>scause</code> 的值为 12，13，15 时说明出现缺页，此时检查 PTE_COW 位，若缺页则分配新物理页、复制原有内容并修改页表映射、引用数；</li><li>在 <code>copyout</code> 中内核也可能访问 COW 页面，此时的处理逻辑和 <code>usertrap</code> 是一样的；</li></ol><p>结合上面的总结，我们有以下几点需要注意：</p><ol><li>对物理页引用数组的更新需要谨慎设计加锁逻辑，不要出现父进程创建新物理页之后还没更新引用数组，又切换到子进程让它以为还需要创建新物理页的情况；</li><li>把一个 cow 页处理为能够正常访问的页面的功能在两个地方都要调用，可以封装为一个函数；这个函数会修改原有 pte 映射的物理地址，不用调用 <code>mappages</code> ，直接改 pte 即可。</li></ol><h1 id="Lab6-Multithreading"><a href="#Lab6-Multithreading" class="headerlink" title="Lab6 Multithreading"></a>Lab6 Multithreading</h1><p>这个实验涉及的核心内容是 xv6 如何实现进程切换。总结起来，每个时钟中断后无论是内核态还是用户态，最后都会调用 <code>yield</code> 函数来让当前进程放弃 CPU 并将控制权交给 kernel 中本来运行着的调度线程，调度线程选一个新进程之后再把控制权交给它。</p><p>所谓控制权的交换，就是上下文的切换，即寄存器内容的切换。通过修改寄存器 <code>ra</code> 的值，函数的返回地址就能改变。</p><h2 id="switching-between-threads"><a href="#switching-between-threads" class="headerlink" title="switching between threads"></a>switching between threads</h2><p>在 xv6 中实现线程切换。和进程切换的逻辑没有任何区别，给每个线程定义一个 <code>context</code> 成员，保存该线程的现场，然后用汇编代码直接交换 context 即可。</p><h2 id="using-threads"><a href="#using-threads" class="headerlink" title="using threads"></a>using threads</h2><p>本题要求用 pthread 库提供的互斥锁实现多线程操作哈希表。题目的哈希表用了头插法，如果不用锁会导致表头指针未指向新元素时切换线程，新线程再插入元素导致内存泄漏。为了加快速度，可以降低锁的粒度，即根据哈希值使用锁。</p><h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><p>本题要求用 pthread 库提供的条件变量实现 barrier：执行到 <code>barrier</code> 的线程会阻塞直到所有线程都执行到这里。这个特性是通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>pthread_cond_broadcast(&amp;bstate.barrier_cond);<br></code></pre></td></tr></table></figure><p>这一对函数来实现的：前者要求已获得锁 <code>bstate.barrier_mutex</code>，它会原子地释放锁并阻塞在条件变量 <code>bstate.barrier_cond</code>；后者会唤醒所有等待在 <code>bstate.barrier_cond</code> 上的线程，同时该线程会尝试重新获取它之前释放的锁。</p><h1 id="Lab7-networking"><a href="#Lab7-networking" class="headerlink" title="Lab7 networking"></a>Lab7 networking</h1><p>在 xv6 中为 E1000 网卡写驱动。看起来相当复杂，但实验基础架构都已经被实现完毕，只要求完成网卡的发送和接收函数。</p><p>完成本实验首先需要知道 E1000 发送接收数据包使用的数据结构是所谓的 <code>tx_desc</code> 和 <code>rx_desc</code>。每个 descriptor 会保存一个 <code>mubf</code> 结构的地址、长度、是否发送/接收完毕等信息。在此基础上，以发送函数为例，我们根据指导书知道 <code>regs[E1000_TDT]</code> 记录着下一个发送 descriptor 的索引，而 <code>tx_mbufs</code> 会保存该 descriptor 对应的 <code>mbuf</code> 链表，我们只需要根据指导书提示及时释放、分配 <code>mbuf</code> 并修改命令字段即可。</p><p>注意发送函数存在竞争，需要加锁；接收函数位于中断处理程序中，没有竞争，但为了及时处理所有块，需要用 <code>while(1)</code> 将函数体包裹。</p><h1 id="Lab8-Lock"><a href="#Lab8-Lock" class="headerlink" title="Lab8 Lock"></a>Lab8 Lock</h1><h2 id="memory-allocator"><a href="#memory-allocator" class="headerlink" title="memory allocator"></a>memory allocator</h2><p>内核通过 kalloc 从 kmem 保存的空闲物理页链表中分配内存，而所有 CPU 共用一个 kmem 的代价是锁的竞争非常激烈，导致并行性的下降。题目要求我们为每个 CPU 单独维护一个空闲物理页链表，当前 CPU 的物理页不够用时从其他 CPU 窃取。</p><p>本题每个 CPU 仅在自己空白页不够用时才会访问其他 CPU 的物理页链表，注意不要在持有锁的同时尝试窃取其他 CPU 的物理页以避免死锁；如果本 CPU 没有空白页，可以直接获取其他 CPU 的锁然后返回它们的空白页，本 CPU 运行 <code>kfree</code> 时会把空白页加到自己的链表。</p><h2 id="buffer-cache"><a href="#buffer-cache" class="headerlink" title="buffer cache"></a>buffer cache</h2><p>本题比上题难得多。首先需要对文件系统有一定了解：内核在内存中为 NBUF 个磁盘块实现了缓存，缓存块被定义在 <code>kernel/buf.h</code> 中；每个 buf 除了保存磁盘块的内容，还记录了设备号、磁盘块号等信息；同时，当某 CPU 想要访问特定块号的磁盘块时，若缓存未命中，则根据 LRU 链表来实现磁盘块替换，因此 buf 还要保存 LRU 链表的指针；此外，读写磁盘块内容时必须加锁，所以 buf 还包含一个睡眠锁。</p><p>内核通过 <code>bread</code> 和 <code>bwrite</code> 来实现对特定磁盘块的读写，其中 <code>bread</code> 会通过 <code>bget</code> 函数获取保存着目标磁盘块的 buf（若缓存未命中则将其替换进内存）；当 CPU 不需要读写该磁盘块时，通过 <code>brelse</code> 释放相应 buf 的锁，并判断是否需要更新其在 LRU 中的位置。为了保持每个 buf 中信息被原子的修改、读取，xv6 采用一个大锁 <code>bcache.lock</code>，而本实验的任务就是将其拆分为若干个小锁以提高并行度，要修改的也就是 <code>bget</code> 和 <code>brelse</code>。</p><p>在上题中给每个 CPU 分配物理页的方式行不通，因为不同于空白物理页用谁的都一样，每个 CPU 都可能不得不访问某个特定的磁盘块。根据 hints，我们将 buf 依据 blockno 拆分为 13 个桶，每个桶单独维护一个链表和一个锁。本题的难点在于，在某个桶中找不到特定磁盘块时，我们需要在已获取当前桶的锁后，去请求其他桶的锁来尝试驱逐页面，这就很可能造成死锁。</p><p>如果规定顺序获取每个桶的锁，那么效率估计还不如大锁，所以缓存未命中时，我们可以先放弃当前桶的锁，然后挨个申请其他桶的锁来驱逐页面。但是这样做引出了新的问题：多个 CPU 对同一个磁盘块进行 bget 时，驱逐过程不加锁可能会导致为了一个页面进行了多次驱逐。考虑到题目 hint 强调：</p><blockquote><p>It is OK to serialize eviction in bget.</p></blockquote><p>所以可以定义一个驱逐锁，同时间只允许一个 CPU 进行驱逐；同时获取该锁后马上检查其他 CPU 是否已经完成了驱逐，若是则直接返回即可。具体的驱逐过程编写也是颇有技巧，但是不在此赘述，只要记得将目标 buf 从原来的桶移入当前桶时，两个桶的锁都必须保持在手中，同时不要忘记释放驱逐锁即可。</p><h1 id="Lab9-File-system"><a href="#Lab9-File-system" class="headerlink" title="Lab9 File system"></a>Lab9 File system</h1><p>文件系统是一个很大的模块，本实验也只是涉及到了其中的一小部分。总的来说，完成本实验大致要了解这些概念：</p><ul><li>inode：磁盘上的 inode 记录着一个文件的类型、（硬）链接数、大小和所有数据块（包括直接块和各级索引块）对应的块号等信息；内存中的 inode 还会额外记录文件的设备号、inode 编号、内存中的引用数、合法性等信息；</li><li>dirent：一个目录项对应一个文件或目录，dirent 中记录着文件名和 inode 编号，目录型文件的 inode 记录的数据块保存着目录中所有文件的 dirent；</li><li>给定文件路径，想要找到其对应的 inode，需要从进程的工作目录或根目录 inode 开始寻找对应名字的 dirent；</li></ul><h2 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h2><p>xv6 文件系统定义的 inode 中包含 12 个直接块和 1 个一级索引块，因此能支持的最大文件可以有 $12 + 256 = 268$ 个磁盘块；本题要求将其改为 11 个直接块、1 个一级索引块、1 个二级索引块，这样修改后的文件系统支持最大文件块数为 $11 + 256 + 256^2=65803$。</p><p>xv6 中 <code>bmap</code> 函数负责读取 inode 的索引块，返回 inode 的第 <code>bn</code> 个数据块对应的磁盘块号。这个题目只需要仿照原版 <code>bmap</code> 对一级索引块的处理，关键的 api 是通过 <code>bread</code> 把指定块号读入内存，二级索引只不过是需要再读一次。记得修改 <code>itrunc</code> 使其能够释放 inode 的所有数据块。</p><h2 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h2><p>这个题目会略难一些，要求在 xv6 中实现软链接。首先要知道软链接是一个独立的文件，有自己的 inode（硬链接则是不同 dirent 指向同一个 inode）；软链接的 inode 中保存其文件类型（xv6 中是 T_SYMLINK）和指向文件的路径（建立软链接时建议用绝对路径，否则移动软链接会找不到指向的文件）。在进程 <code>open</code> 一个软链接时，内核会自动递归寻找其指向的文件（用户进程可以通过指定 O_NOFOLLOW 参数来打开软链接本身）。</p><p>题目通过实现一个系统调用 <code>symlink(char *target, char *path)</code> 在 <code>path</code> 处创建一个指向 <code>target</code> 的软链接。这里完全可以参考 <code>sys_mknod</code> 创建设备文件的思路，通过 <code>create</code> 在指定路径创建一个 <code>T_SYMLINK</code> 类型的 inode，再调用 <code>writei</code> 向 inode 中写入目标路径。接下来需要修改 <code>open</code>，获取到目标 inode 后判断其是否为软链接类型，如果是则递归寻找其指向文件的 inode，这里的关键 api 是：</p><ul><li>readi：用于读取软链接的文件内容以确定其指向文件的路径；</li><li>namei：根据路径返回 inode 指针。</li></ul><p>如果软链接之间形成了环，可以在递归层数超过 10 时直接报错；记得关注 inode 的锁是否在递归中及时释放了。</p><h1 id="Lab10-mmap"><a href="#Lab10-mmap" class="headerlink" title="Lab10 mmap"></a>Lab10 mmap</h1><p>本实验要求为 xv6 实现一个系统调用 <code>mmap</code>。整个实验并没有太多难点，但是代码量比较大，调试也会有一定难度。实验只要求实现 <code>mmap</code> 的一个（玩具）功能，即将进程的一段虚拟地址空间映射到一个打开的文件中，并通过读写这段地址来间接访问文件。这样做可以方便多个进程对同一个文件的共享（尤其是只读的代码段等），也可以加速一个进程对文件的读写（不必通过 <code>read</code> 和 <code>write</code> 频繁进入内核空间并访问缓冲区等）。</p><blockquote><p>值得一提的是，常用的 <code>malloc</code> 作为一个用户态库函数，其底层也依赖系统调用 <code>mmap</code> （或是 <code>sbrk</code>）。</p></blockquote><p>整个实验的核心是指导书中提示的 VMA 结构，它保存着一块被映射虚拟地址的起点、长度、文件描述符、读写权限、是否共享等关键信息，每个进程都应当有自己的 VMA 数组（或链表）。本实验的核心问题在于如何为进程寻找未被使用的虚拟地址。事实上我们可以直接从进程的 <code>sz</code> 成员开始分配，虽然在 <code>munmap</code> 后会导致内存泄漏，且释放进程内存时会出现很多为 0 的 pte，但足以满足本实验的要求。</p><p>在 <code>sys_mmap</code> 中设置好 VMA 后，下一步是在 <code>usertrap</code> 中完成对缺页异常的处理（因为采用了懒分配），也就是判断是否为 <code>mmap</code> 导致的缺页，如果是则分配新物理页，将文件相应位置内容读进来，并且完成用户进程的页面映射。接下来需要实现 <code>munmap</code>，思路就是清空 pte，释放页面，并根据页面是否为 shared 决定是否需要写回原文件。至于 <code>fork</code> 和 <code>exit</code> 的修改不必赘述。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自顶向下的语法分析</title>
    <link href="/2022/11/16/top_down_parser/"/>
    <url>/2022/11/16/top_down_parser/</url>
    
    <content type="html"><![CDATA[<p>自顶向下分析试图从初始符号开始，给出目标句子的一个推导。</p><h1 id="递归下降分析法"><a href="#递归下降分析法" class="headerlink" title="递归下降分析法"></a>递归下降分析法</h1><h2 id="递归下降分析的实现"><a href="#递归下降分析的实现" class="headerlink" title="递归下降分析的实现"></a>递归下降分析的实现</h2><p>递归下降分析法从直观上是很好理解的，以如下文法为例：</p><ul><li>$E\rightarrow T|T+E$</li><li>$T\rightarrow int|int\ast T|(E)$</li></ul><p>定义全局指针 <code>next</code> 指向下一个待读入的 token，以及函数 <code>term</code> 来判断该 token 是否为指定类型终结符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">term</span><span class="hljs-params">(Token tok)</span>&#123;<br>    <span class="hljs-keyword">return</span> *next++ == tok;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后根据每个产生式，定义一系列相互递归调用的函数来判断目标句子是否符合文法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">E1</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> T();&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">E2</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> T()&amp;&amp;term(PLUS)&amp;&amp;E();&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">E</span><span class="hljs-params">()</span>&#123;<br>    Token *save = next;<br>    <span class="hljs-keyword">return</span> (next = save, E1())<br>        || (next = save, E2());<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> term(INT);&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> term(INT)&amp;&amp;term(TIMES)&amp;&amp;T();&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">T3</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> term(OPEN)&amp;&amp;E()&amp;&amp;term(CLOSE);&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">T</span><span class="hljs-params">()</span>&#123;<br>    Token *save = next;<br>    <span class="hljs-keyword">return</span> (next = save, T1())<br>        || (next = save, T2())<br>        || (next = save, T3());<br>&#125;<br></code></pre></td></tr></table></figure><br>初始化 <code>next</code> 指针后，调用 <code>E</code> 即可判断目标句子是否符合文法。</p><h2 id="递归下降分析的局限性"><a href="#递归下降分析的局限性" class="headerlink" title="递归下降分析的局限性"></a>递归下降分析的局限性</h2><p>上面展示的递归下降分析法非常便于手写实现，但是却不具有通用性，能够识别的语法也是有限的，下面介绍其几个主要的局限性。</p><h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>用上面的程序分析句子 int*int 无法成功，这是因为 int 可以同时作为产生式 $T\rightarrow int$和$T\rightarrow int\ast T$的前缀，但只有后者是正确的，上述程序无法处理这种二义性。</p><p>这个问题可以通过增加<strong>回溯</strong>解决，而不增加代码编写难度的做法则是<strong>提取左因子</strong>，即将一个非终结符具有相同前缀的多个产生式进行重写。对于本例，可以将</p><ul><li>$T\rightarrow int|int\ast T|(E)$</li></ul><p>改写为</p><ul><li>$T\rightarrow intA|(E)$</li><li>$A\rightarrow\ast T|\varepsilon$</li></ul><h3 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h3><p>考虑产生式</p><ul><li>$S\rightarrow Sa|b$</li></ul><p>其对应的分析函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">S</span><span class="hljs-params">()</span>&#123;<br>    Token *save = next;<br>    <span class="hljs-keyword">return</span> (next = save, S()&amp;&amp;term(a))<br>        || (next = save, term(b));<br>&#125;<br></code></pre></td></tr></table></figure><br>显然这个函数会陷入无穷的递归调用而无法返回。上述现象称为<strong>直接左递归</strong>，若通过中间变量产生左递归则成为间接左递归。想要让递归下降分析法正确工作，就需要通过引入中间变量来消除左递归。</p><p>对于上述文法，可以将其改写为</p><ul><li>$S\rightarrow bA$</li><li>$A\rightarrow aA|\varepsilon$</li></ul><h1 id="预测分析：LL分析法"><a href="#预测分析：LL分析法" class="headerlink" title="预测分析：LL分析法"></a>预测分析：LL分析法</h1><p>递归下降分析法无法避免选择了错误的产生式后进行的大量回溯。如果能够根据后续字符选择唯一的产生式，就能够提高解析的效率。LL分析法就是这样一种预测型的自顶向下解析法：LL(k)的含义是从左向右、最左派生、根据后续的 k 个 token 来预测产生式。</p><p>具体来说，LL分析法用一个栈来存储推导过程中产生的终结符和非终结符，同时利用一张预测分析表指出在已知当前栈顶符号和下一个读入 token 的情况下应当如何对该符号进行推导。</p><h2 id="First、Follow集"><a href="#First、Follow集" class="headerlink" title="First、Follow集"></a>First、Follow集</h2><p>为了能够进行产生式的预测，需要考察文法中非终结符和终结符之间的关系。为此引入了$First$和$Follow$集的概念。对于非终结符$A$而言：</p><ul><li><p>$First(A)$指$A$能派生出的所有句子的第一个终结符的集合；</p></li><li><p>$Follow(A)$指该文法派生过程中所有可能出现在$A$后的第一个终结符的集合。</p></li></ul><p>注意，$\varepsilon\in First(A)$的条件较为特殊，是$A$能推导出空串。</p><h2 id="LL-1-分析表"><a href="#LL-1-分析表" class="headerlink" title="LL(1) 分析表"></a>LL(1) 分析表</h2><p>藉由$First$和$Follow$集的概念，我们可以构造 LL(1) 分析表。</p><p>对每个产生式 $A\rightarrow\alpha$ 进行如下操作：</p><ol><li>对所有 $t\in First(\alpha),T[A][t]=\alpha$</li><li>如果 $\varepsilon\in Fisrt(\alpha)$，对所有 $t\in Follow(A),T[A][t]=\alpha$</li></ol><p>若某个表项有多个可用产生式，那么该文法不是 LL(1) 文法；若某个表项无可用产生式，说明 LL 分析在该状态遇到了错误，识别失败。</p><h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><ol><li>将#放入符号栈；</li><li>将文法初始符号$S$放入符号栈；</li><li>从缓冲区读入读指针指向的 token $t$;</li><li>若从符号栈栈顶取出符号$A$：<ul><li>若$A$是终结符，且等于$t$，则$A$出栈，缓冲区读指针后移；</li><li>若$A$是非终结符，且$T[A][t]=\alpha$，则$A$出栈，将$\alpha$中符号<strong>倒序入栈</strong>，缓冲区读指针不动；</li><li>否则进行错误处理；</li></ul></li><li>若符号栈为空则已识别完成，否则回到 3。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ELGamal算法及其原根的求取</title>
    <link href="/2022/11/15/elgamal/"/>
    <url>/2022/11/15/elgamal/</url>
    
    <content type="html"><![CDATA[<p>ELGamal 是 RSA 之外的另一个公钥加密体系，于 1985 年提出。相较于 RSA，ELGamal 的运算速度更慢，密文长度更大；其优势是对于质数大小的要求更低一些，而且由于随机数的选取，即使是同一个私钥，加密同样的信息，也会得到不同的结果，提高了安全性。</p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><p>设$G$是一个具有代数运算$\circ$的非空集合，满足：</p><ul><li>结合律：$\forall a,b,c\in G$，有$(a\circ b)\circ c=a\circ(b\circ c)$；</li><li>单位元：$\exists e\in G$，满足$\forall a\in G,e\circ a=a\circ e=a$；</li><li>逆元：$\forall a\in G$，存在$a^{-1}\in G,a\circ a^{-1}=a^{-1}\circ a=e$；</li></ul><p>称$G$关于$\circ$构成一个<strong>群</strong>（group）。满足交换律的群称为交换群（阿贝尔群）。根据元素是否有限，群分为有限群和无限群；有限群$G$中的元素个数称为群的<strong>阶</strong>，记为$|G|$。</p><p>在模$m$的<a href="https://ch3chohch3.github.io/2022/10/20/rsa/#%E7%AE%80%E5%8C%96%E5%89%A9%E4%BD%99%E7%B3%BB">简化剩余系</a>中，考虑模$m$意义下的乘法运算；乘法满足结合律，$1$是单位元，且由扩展欧几里得算法每个元素都有模$m$意义下的乘法逆元。因此，模$m$的简化剩余系关于模$m$意义下的乘法构成一个群，记作$Z_m^\ast$。</p><h2 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h2><p>在群上定义幂运算，即$a^n=a\circ a\circ…\circ a$（共$n$个$a$），同时规定：</p><ul><li>$a^0=e$</li><li>$a^{-n}=(a^{-1})^n$</li></ul><p>对于群中的元素$a$，其阶$|a|$指的是使$a^m=e$成立的最小正整数$m$。若群$G$中存在元素$a$，使得$G$中所有元素都能由$a$的幂表示，则称$G$为<strong>循环群</strong>，元素$a$为$G$的生成元，记作$G=\langle a\rangle$。</p><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>设$gcd(a,m)=1$，若使$a^d\equiv 1\pmod m$成立的最小正整数$d=\varphi(m)$，则称$a$是模$m$的<strong>原根</strong>。藉由原根的概念，我们来证明当$m$有原根时，<strong>模$m$的简化剩余系乘群是一个循环群，其生成元为$m$的原根</strong>。</p><p>显然$|Z_m^\ast|=\varphi(m)$，考虑$m$的一个原根$a\in Z_m^\ast$，若要证明$Z_m^\ast$是以$a$为生成元的循环群，则只需证</p><script type="math/tex; mode=display">a^0,a^1,...,a^{\varphi(m)-1}</script><p>在模$m$意义下两两不同。设正整数$x,y$满足</p><script type="math/tex; mode=display">0\leq x<y\leq\varphi(m)-1,</script><p>若</p><script type="math/tex; mode=display">a^x\equiv a^y\pmod m,</script><p>则有$a^{y-x}\equiv1\pmod m$，易知$0&lt;y-x&lt;\varphi(m)$，这与$a$是模$m$的原根矛盾，因此</p><script type="math/tex; mode=display">a^0,a^1,...,a^{\varphi(m)-1}</script><p>在模$m$意义下两两不同。反之，这也证明$Z_m^\ast$中不是$m$原根的元素一定不是生成元。</p><blockquote><p>上面我们证明了$Z_m^\ast$的生成元和$m$的原根是一一对应的关系，与此同时，我们还容易证明有限循环群$G$生成元的个数为$\varphi(|G|)$，进而可以得到$m$原根的个数恰为$\varphi(\varphi(m))$。另外，并非所有正整数都有原根，只有当$m=2,4,p^n,2p^n$（$p$为奇素数，$n$为正整数）时，$m$才有原根。</p></blockquote><h2 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h2><p>设$G=\langle a\rangle$，群$G$中的离散对数问题是指：给定$G$中元素$h$，找到正整数$k$满足</p><script type="math/tex; mode=display">h=a^k.</script><p>我们把$k$称为$h$相对于生成元的离散对数，记作</p><script type="math/tex; mode=display">k=log_ah.</script><p>$Z_m^\ast$中，已知生成元和指定元素，求离散对数的问题是一个困难问题；如同 RSA 中蕴含的困难问题是大数质因数分解，ELGamal 的安全性基于离散对数的求解难题。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><ol><li>取一个较大素数$p$；</li><li>求$Z_p^\ast$的一个生成元$g$；</li><li>任取$1&lt;\alpha&lt;p-1$，计算$\beta=g^\alpha\bmod p$；</li></ol><p>其中$(p,g,\beta)$作为公钥，$\alpha$作为私钥。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><ol><li>给定待加密信息$x$，选择随机整数$1&lt;k&lt;p-1$；</li><li>计算$E(x,k)=(r,s)$，其中$r=g^k\bmod p$，$s=x\beta^k\bmod p$；</li></ol><p>$(r,s)$就是加密完成后的信息。</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><ol><li>收到信息$(r,s)$；</li><li>计算$D(r,s)=sr^{-\alpha}\bmod p=xg^{\alpha k}g^{-\alpha k}\bmod p=x$；</li></ol><p>这样就得到明文$x$。</p><h1 id="原根的求取"><a href="#原根的求取" class="headerlink" title="原根的求取"></a>原根的求取</h1><p>在实际使用 ELGamal 加密时，一个难点在于如何获取较大素数的原根。我们知道有限群中任意元素的阶整除群的阶，那么对于$Z_p^\ast$而言，所有元素的阶都是$\varphi(p)=p-1$的因数。这为我们提供了一种方法：</p><ol><li>随机生成大质数$q$，直到$p=2q+1$也是质数；</li><li>随机选取$1&lt;g&lt;p-1$，那么$g$的阶必然是$p-1=2q$的因数，即$g$的阶只有$2,q,2q$三种可能。</li><li>若$g^2\equiv1\pmod p$或$g^q\equiv1\pmod p$，说明$g$不是$p$的原根，否则$g$即为求得的一个原根。</li></ol><p>随机选取$g$的形式虽然看起来时间开销无法保障，但是对于$p=2q+1$而言，其原根的个数有$\varphi(\varphi(p))=q-1$之多，即每次随机选取有$\frac{1}{2}$的概率选取到原根，所以实际上不会花费很多时间。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA算法介绍</title>
    <link href="/2022/10/20/rsa/"/>
    <url>/2022/10/20/rsa/</url>
    
    <content type="html"><![CDATA[<h1 id="非对称密码（公钥密码）体系"><a href="#非对称密码（公钥密码）体系" class="headerlink" title="非对称密码（公钥密码）体系"></a>非对称密码（公钥密码）体系</h1><p>非对称密码体系是 1976 年被正式提出的概念，弥补了对称密码的一些缺陷。</p><p>其基本方案是：用户生成公钥 $pub$ 和私钥 $pri$，公钥向他人公开并用于信息加密，私钥由本人保管并用于信息解密。</p><p>RSA 是 1977 年被提出的公钥密码算法，其核心原理是数论中的欧拉定理，被广泛用于互联网的方方面面（包括 ssh，https 等关键设施）。在量子 计算机还未成熟的今天，RSA 可谓公钥密码体系的中流砥柱。</p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="完全剩余系"><a href="#完全剩余系" class="headerlink" title="完全剩余系"></a>完全剩余系</h2><p>给定正整数 $m$，全体整数根据模 $m$ 的余数显然可以划分为 $m$ 个集合，每个这样的集合称为模 $m$ 的<strong>剩余类</strong>；在整数模 $m$ 的所有剩余 类中各取一个代表元，构成的集合称为模 $m$ 的<strong>完全剩余系</strong>，其中 ${0,1,…,m-1}$ 为<strong>最小非负完全剩余系</strong>。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理 1"></a>定理 1</h3><p>设 $m$ 为正整数，整数 $a$ 和 $m$ 互素，$b$ 为任意整数，$x$ 是模 $m$ 的一个完全剩余系，则 $ax+b$ 也是模 $m$ 的一个完全剩余系。</p><h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理 2"></a>定理 2</h3><p>设 $m_1,m_2$ 为两个互素的正整数。若 $x$ 为模 $m_1$ 的一个完全剩余系，$y$ 为模 $m_2$ 的一个完全剩余系，则 $m_1y+m_2x$ 为模 $m_1m_2$ 的一个完全剩余系。</p><h2 id="简化剩余系"><a href="#简化剩余系" class="headerlink" title="简化剩余系"></a>简化剩余系</h2><p>在模 $m$ 的一个剩余类中，如果有一个数与 $m$ 互素，则显然该剩余类中所有的数均与 $m$ 互素，此时称该剩余类与 $m$ 互素。与 $m$ 互素的剩余类的个数称为欧拉函数，记为 $\varphi(m)$，其值等于 $1$ 到 $m-1$ 中与 $m$ 互素的数的个数。欧拉函数有两个重要性质：</p><ul><li>对于任意素数 $p$ 有 $\varphi(p)=p-1$；</li><li>若 $m,n$ 互素，则 $\varphi(mn)=\varphi(m)\varphi(n)$。</li></ul><p>在与 $m$ 互素的 $\varphi(m)$ 个模 $m$ 的剩余类中各取一个代表元，组成的集合称为模 $m$ 的一个<strong>简化剩余系</strong>或<strong>既约剩余系</strong>。例如 ${1,5,7,11}$ 构成模 $12$ 的一个简化剩余系。</p><h3 id="定理-3"><a href="#定理-3" class="headerlink" title="定理 3"></a>定理 3</h3><p>设 $m$ 是正整数，整数 $a$ 与 $m$ 互素。若 $x$ 为 $m$ 的一个简化剩余系，则 $ax$ 也是 $m$ 的一个简化剩余系。</p><h3 id="定理-4"><a href="#定理-4" class="headerlink" title="定理 4"></a>定理 4</h3><p>设 $m_1,m_2$ 是两个互素的正整数，如果 $x$ 是 $m_1$ 的一个简化剩余系，$y$ 是 $m_2$ 的一个简化剩余系，则 $m_1y+m_2x$ 是 $m_1m_2$ 的一个简化剩余系。</p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><h3 id="定理-5"><a href="#定理-5" class="headerlink" title="定理 5"></a>定理 5</h3><p>将 $m$ 质因数分解得到</p><script type="math/tex; mode=display">m=p_1^{e_1}p_2^{e_2}...p_n^{e_n},</script><p>则</p><script type="math/tex; mode=display">\varphi(m)=m\prod_{i=1}^{n}(1-\frac{1}{p_i}).</script><h3 id="定理-6（欧拉定理）"><a href="#定理-6（欧拉定理）" class="headerlink" title="定理 6（欧拉定理）"></a>定理 6（欧拉定理）</h3><p>设 $r,m$ 是正整数，且 $gcd(r,m)=1$，则 $r^{\varphi(m)}\equiv 1\pmod{m}$。</p><p>证明：取模 $m$ 的一组简化剩余系</p><script type="math/tex; mode=display">\{r_1,r_2,...,r_\varphi(m)\},</script><p>由定理 3 知</p><script type="math/tex; mode=display">\{rr_1,rr_2,···,rr_\varphi(m)\},</script><p>也是模 $m$ 的一组简化剩余系，则有</p><script type="math/tex; mode=display">\prod_{i=1}^{\varphi(m)}r_i\equiv\prod_{i=1}^{\varphi(m)}rr_i\equiv r^{\varphi(m)}\prod_{i=1}^{\varphi(m)}r_i\pmod m，</script><p>又</p><script type="math/tex; mode=display">gcd(\prod_{i=1}^{\varphi(m)}r_i,m)=1，</script><p>因此 $r^{\varphi(m)}\equiv 1\pmod m$。</p><h2 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h2><p>扩展欧几里德算法在 RSA 中用于求模意义下的乘法逆元。简单来说，给定整数 $a,b$，则 $a$ 在模 $b$ 意义下的乘法逆元 $x$ 满足 $ax\equiv 1\pmod{b}$，即 $ax=by+1$，求出 $ax+by=1$ 的一组正整数解即可。</p><p>想要求二元一次方程 $ax+by=c$ 的整数解，其有解的前提是 $gcd(a,b)|c$。利用欧几里德算法求最大公因数的思想：</p><script type="math/tex; mode=display">gcd(a,b)=gcd(b,a-b\lfloor\frac{a}{b}\rfloor).</script><p>每次递归会削减 $a,b$ 的大小，且最终一定会递归至 $gcd(a’,0)$ 的情形，此时 $a’$ 即二者的最大公因数。因此，为了求解 $ax+by=c$，我们可 以先求方程 $bx’+(a-b\lfloor\frac{a}{b}\rfloor )y’=c$ 的解，原因有两个：</p><ol><li>从后者的解可以推出前者的解。求出 $x’,y’$ 的值后，对比两个方程：<script type="math/tex; mode=display">ax+by=c,</script><script type="math/tex; mode=display">ay'+b(x'-y'\lfloor\frac{a}{b}\rfloor)=c,</script>显然可以求出 $x=y’,y=x’-y’\lfloor\frac{a}{b}\rfloor.$</li><li>递归求解的过程是有边界的，即最终会递归至：<script type="math/tex; mode=display">a'x'=c.</script>由欧几里德算法，此时的 $a’$ 即为最初 $a,b$ 的最大公因数，只要此方程有解即可通过回代求出最初方程的解。</li></ol><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>RSA 基于这样一个事实：计算两个大质数的乘积很容易，但将乘积分解回两个质数很困难。其具体流程如下：</p><ol><li>选取两个大质数 $p,q$，令 $n=pq$，则 $\varphi(n)=(p-1)(q-1)$；</li><li>任取一小于 $\varphi(n)$ 的正整数 $e$，要求 $e$ 与 $\varphi(n)$ 互质；</li><li>用扩展欧几里德算法求 $e$ 在模 $\varphi(n)$ 意义下的乘法逆元 $d$，即 $ed\equiv 1\pmod{\varphi(n)}$;</li><li>公钥为 $(n,e)$，私钥为 $(n,d)$。</li></ol><p>加密明文 $m$ 时，密文 $c=m^e\bmod n$；解密密文 $c$ 时，显然 $m$ 和 $n$ 应当是互质的，由欧拉定理可得：</p><script type="math/tex; mode=display">m^{\varphi(n)}\equiv 1\pmod{n},</script><p>因此</p><script type="math/tex; mode=display">c^d\equiv m^{ed}\equiv m^{1+k\varphi(n)}\equiv m(m^{\varphi(n)})^k\equiv m\pmod{n}.</script><p>试想，作为一个攻击者，在已知公钥 $(n,e)$ 的前提下，想要获取私钥 $(n,d)$ 就必须求出 $\varphi(n)$ ，也就是得到 $p,q$ 的值；但在 $n$  足够大的前提下，对其进行质因数分解几乎 只有暴力枚举一种方法，这便是 RSA 安全性的根本来源。</p><h1 id="RSA-之大素数生成"><a href="#RSA-之大素数生成" class="headerlink" title="RSA 之大素数生成"></a>RSA 之大素数生成</h1><p>通过上面对 RSA 算法的介绍，引出了一个新的问题：如何获得足够大的随机质数。</p><p>目前 RSA 的主流密钥长度都在 1024 位以上，即 $p,q$ 的长度要在 512 位。面对 $2^{512}$ 这样的数量级，无论是试除还是筛法都已经不能满足 筛选质数的要求。</p><p>目前对于大质数的判断还没有能百分百符合要求的算法。主流的算法是随机生成一个大数，通过 Miller-Rabin 算法概率性地判断其是否为质数，如 果不是的话则在这个大数附近继续随机地寻 找（根据质数分布的规律，这个随机寻找的过程不会花费太多的时间）。Miller-Rabin 算法在足够多的检测次数下几乎不会判断错误（64 轮检测后误判概率小于 $2^{-128}$），因此能够符合 工业级的加密场景。</p><p>事实上，百分百确定的素性测试算法也已经被提出了，即 AKS 素数测试算法；虽然其性能仍然不能满足需求，但具有重要的学术意义。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xv6 驱动和中断——输入输出</title>
    <link href="/2022/08/31/xv6_itrpt/"/>
    <url>/2022/08/31/xv6_itrpt/</url>
    
    <content type="html"><![CDATA[<p>在 xv6 启动时，shell 会向屏幕打印 <code>$</code> 表示等待用户输入；当用户从键盘输入 <code>ls</code> 时，屏幕会显示这两个字符。在这些设备工作的过程中，xv6 内核究竟扮演了什么角色，又是如何实现的呢？</p><h1 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h1><p>设备驱动是内核中的代码，用于管理特定硬件设备。驱动通常分为 top 和 bottom 两部分：top 通常是内核希望与设备沟通时调用的，而 bottom 则是设备向内核发起中断时的处理程序。</p><p>当内核希望与设备进行交互时，<code>read</code> 和 <code>write</code> 等系统调用最终会执行到驱动程序的 top 部分，来让设备执行操作；当操作完成后，设备产生中断，驱动的 bottom 部分开始执行，唤醒等待该设备的进程，并让设备进行新的工作。</p><h1 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h1><p>内核的 <code>main</code> 首先调用 <code>consoleinit</code> 对控制台进行初始化，该函数调用 <code>uartinit</code> 设置 UART 的传输波特率，重置其缓冲区，最后开启<strong>接收中断</strong>和<strong>发送完成中断</strong>。接下来，<code>consoleinit</code> 分别将 CONSOLE 设备的 <code>read</code> 和 <code>write</code> 函数设置为 <code>consoleread</code> 和 <code>consolewrite</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/console.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">consoleinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  initlock(&amp;cons.lock, <span class="hljs-string">&quot;cons&quot;</span>);<br><br>  uartinit();<br><br>  <span class="hljs-comment">// connect read and write system calls</span><br>  <span class="hljs-comment">// to consoleread and consolewrite.</span><br>  devsw[CONSOLE].read = consoleread;<br>  devsw[CONSOLE].write = consolewrite;<br>&#125;<br><span class="hljs-comment">// kernel/uart.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// disable interrupts.</span><br>  WriteReg(IER, <span class="hljs-number">0x00</span>);<br><br>  <span class="hljs-comment">// special mode to set baud rate.</span><br>  WriteReg(LCR, LCR_BAUD_LATCH);<br><br>  <span class="hljs-comment">// LSB for baud rate of 38.4K.</span><br>  WriteReg(<span class="hljs-number">0</span>, <span class="hljs-number">0x03</span>);<br><br>  <span class="hljs-comment">// MSB for baud rate of 38.4K.</span><br>  WriteReg(<span class="hljs-number">1</span>, <span class="hljs-number">0x00</span>);<br><br>  <span class="hljs-comment">// leave set-baud mode,</span><br>  <span class="hljs-comment">// and set word length to 8 bits, no parity.</span><br>  WriteReg(LCR, LCR_EIGHT_BITS);<br><br>  <span class="hljs-comment">// reset and enable FIFOs.</span><br>  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);<br><br>  <span class="hljs-comment">// enable transmit and receive interrupts.</span><br>  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);<br><br>  initlock(&amp;uart_tx_lock, <span class="hljs-string">&quot;uart&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，<code>main</code> 会调用 <code>plicinit</code> 和 <code>plicinithart</code>，告诉 PLIC 哪些设备中断被允许，并设置当前 CPU 对哪些中断感兴趣。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/plic.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">plicinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// set desired IRQ priorities non-zero (otherwise disabled).</span><br>  *(uint32*)(PLIC + UART0_IRQ*<span class="hljs-number">4</span>) = <span class="hljs-number">1</span>;<br>  *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="hljs-number">4</span>) = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">void</span><br><span class="hljs-title function_">plicinithart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> hart = cpuid();<br>  <br>  <span class="hljs-comment">// set enable bits for this hart&#x27;s S-mode</span><br>  <span class="hljs-comment">// for the uart and virtio disk.</span><br>  *(uint32*)PLIC_SENABLE(hart) = (<span class="hljs-number">1</span> &lt;&lt; UART0_IRQ) | (<span class="hljs-number">1</span> &lt;&lt; VIRTIO0_IRQ);<br><br>  <span class="hljs-comment">// set this hart&#x27;s S-mode priority threshold to 0.</span><br>  *(uint32*)PLIC_SPRIORITY(hart) = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续用于运行进程的 <code>scheduler</code> 中，<code>intr_on</code> 会打开 CPU 的中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/riscv.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">intr_on</span><span class="hljs-params">()</span><br>&#123;<br>  w_sstatus(r_sstatus() | SSTATUS_SIE);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="shell-的启动流程"><a href="#shell-的启动流程" class="headerlink" title="shell 的启动流程"></a>shell 的启动流程</h1><p>当初始化的工作完成后，内核启动第一个进程 init。可以看到 init 先是通过 <code>mknode</code> 创建设备 CONSOLE，接下来将文件描述符 0，1，2 都指向 CONSOLE；然后通过 <code>fork</code> 和 <code>exec</code> 运行 shell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// user/init.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> pid, wpid;<br><br>  <span class="hljs-keyword">if</span>(open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;<br>    mknod(<span class="hljs-string">&quot;console&quot;</span>, CONSOLE, <span class="hljs-number">0</span>);<br>    open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR);<br>  &#125;<br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout</span><br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr</span><br><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: starting sh\n&quot;</span>);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: fork failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>      exec(<span class="hljs-string">&quot;sh&quot;</span>, argv);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: exec sh failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>      <span class="hljs-comment">// this call to wait() returns if the shell exits,</span><br>      <span class="hljs-comment">// or if a parentless process exits.</span><br>      wpid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span>(wpid == pid)&#123;<br>        <span class="hljs-comment">// the shell exited; restart it.</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wpid &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: wait returned an error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// it was a parentless process; do nothing.</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>shell 先是检查文件描述符是否正确，然后就陷入 <code>getcmd</code> 的循环之中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// user/sh.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">int</span> fd;<br><br>  <span class="hljs-comment">// Ensure that three file descriptors are open.</span><br>  <span class="hljs-keyword">while</span>((fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>      close(fd);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Read and run input commands.</span><br>  <span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>      <span class="hljs-comment">// Chdir must be called by the parent, not the child.</span><br>      buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// chop \n</span><br>      <span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>      runcmd(parsecmd(buf));<br>    wait(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看 <code>getcmd</code>，发现其先是调用 <code>write</code> 向 CONSOLE 中打印 <code>$</code>，然后通过 <code>gets</code> 获取命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// user/sh.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">getcmd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> nbuf)</span><br>&#123;<br>  write(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;$ &quot;</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, nbuf);<br>  gets(buf, nbuf);<br>  <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-comment">// EOF</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="shell-的输入输出"><a href="#shell-的输入输出" class="headerlink" title="shell 的输入输出"></a>shell 的输入输出</h1><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>先来关注 <code>write</code>。我们知道 <code>write</code> 是系统调用，会执行到 <code>sys_write</code>，而 <code>sys_write</code> 则调用了 <code>filewrite</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/sysfile.c</span><br>uint64<br><span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-type">int</span> n;<br>  uint64 p;<br>  <br>  argaddr(<span class="hljs-number">1</span>, &amp;p);<br>  argint(<span class="hljs-number">2</span>, &amp;n);<br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> filewrite(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>filewrite</code> 中，先是判断要输出到的文件类型，如果是设备文件则直接调用该设备的 <code>write</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/file.c</span><br><span class="hljs-comment">// Write to file f.</span><br><span class="hljs-comment">// addr is a user virtual address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">filewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> r, ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;writable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    ret = pipewrite(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>, addr, n);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>因此，这里执行的就是我们在开头设置的 <code>consolewrite</code>，也即 CONSOLE 驱动的 top 部分。<code>consolewrite</code> 对每个字符，先是把数据从用户空间复制，然后调用 <code>uartputc</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//kernel/console.c</span><br><span class="hljs-comment">// user write()s to the console go here.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">consolewrite</span><span class="hljs-params">(<span class="hljs-type">int</span> user_src, uint64 src, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    uartputc(c);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>再来看 <code>gets</code>，其通过系统调用 <code>read</code> 来读取一行字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// user/ulib.c</span><br><span class="hljs-type">char</span>*<br><span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> max)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, cc;<br>  <span class="hljs-type">char</span> c;<br><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i+<span class="hljs-number">1</span> &lt; max; )&#123;<br>    cc = read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(cc &lt; <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    buf[i++] = c;<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == <span class="hljs-string">&#x27;\r&#x27;</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>read</code> 和 <code>write</code> 的调用路径是类似的，通过 <code>sys_read</code>、<code>fileread</code> 最终到达 <code>consoleread</code>。<code>consoleread</code> 比 <code>consolewrite</code> 要复杂，它从缓冲区 <code>cons.buf</code> 中读取整行的输入到用户空间，如果无字符可读或读完缓冲区后该行仍未结束，则会进入 <code>sleep</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/console.c</span><br><span class="hljs-comment">// user read()s from the console go here.</span><br><span class="hljs-comment">// copy (up to) a whole input line to dst.</span><br><span class="hljs-comment">// user_dist indicates whether dst is a user</span><br><span class="hljs-comment">// or kernel address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">consoleread</span><span class="hljs-params">(<span class="hljs-type">int</span> user_dst, uint64 dst, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint target;<br>  <span class="hljs-type">int</span> c;<br>  <span class="hljs-type">char</span> cbuf;<br><br>  target = n;<br>  acquire(&amp;cons.lock);<br>  <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// wait until interrupt handler has put some</span><br>    <span class="hljs-comment">// input into cons.buffer.</span><br>    <span class="hljs-keyword">while</span>(cons.r == cons.w)&#123;<br>      <span class="hljs-keyword">if</span>(killed(myproc()))&#123;<br>        release(&amp;cons.lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      sleep(&amp;cons.r, &amp;cons.lock);<br>    &#125;<br><br>    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];<br><br>    <span class="hljs-keyword">if</span>(c == C(<span class="hljs-string">&#x27;D&#x27;</span>))&#123;  <span class="hljs-comment">// end-of-file</span><br>      <span class="hljs-keyword">if</span>(n &lt; target)&#123;<br>        <span class="hljs-comment">// Save ^D for next time, to make sure</span><br>        <span class="hljs-comment">// caller gets a 0-byte result.</span><br>        cons.r--;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the input byte to the user-space buffer.</span><br>    cbuf = c;<br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br><br>    dst++;<br>    --n;<br><br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>      <span class="hljs-comment">// a whole line has arrived, return to</span><br>      <span class="hljs-comment">// the user-level read().</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  release(&amp;cons.lock);<br><br>  <span class="hljs-keyword">return</span> target - n;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="UART-的工作原理"><a href="#UART-的工作原理" class="headerlink" title="UART 的工作原理"></a>UART 的工作原理</h1><h2 id="字符的输出"><a href="#字符的输出" class="headerlink" title="字符的输出"></a>字符的输出</h2><p>现在我们知道，shell 的输入输出最终通过内核中 CONSOLE 驱动的 top 部分进行，接下来就是最底层的 UART 部分。先来看 <code>uartputc</code>，这里使用了一个生产者-消费者模型的环形队列，并最终通过 <code>uartstart</code> 发送字符给 UART，如果队列已满则会陷入 <code>sleep</code> 等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/uart.c</span><br><span class="hljs-comment">// add a character to the output buffer and tell the</span><br><span class="hljs-comment">// UART to start sending if it isn&#x27;t already.</span><br><span class="hljs-comment">// blocks if the output buffer is full.</span><br><span class="hljs-comment">// because it may block, it can&#x27;t be called</span><br><span class="hljs-comment">// from interrupts; it&#x27;s only suitable for use</span><br><span class="hljs-comment">// by write().</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  acquire(&amp;uart_tx_lock);<br><br>  <span class="hljs-keyword">if</span>(panicked)&#123;<br>    <span class="hljs-keyword">for</span>(;;)<br>      ;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;<br>    <span class="hljs-comment">// buffer is full.</span><br>    <span class="hljs-comment">// wait for uartstart() to open up space in the buffer.</span><br>    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);<br>  &#125;<br>  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;<br>  uart_tx_w += <span class="hljs-number">1</span>;<br>  uartstart();<br>  release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>uartstart</code> 会尝试向 UART 发送字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/uart.c</span><br><span class="hljs-comment">// if the UART is idle, and a character is waiting</span><br><span class="hljs-comment">// in the transmit buffer, send it.</span><br><span class="hljs-comment">// caller must hold uart_tx_lock.</span><br><span class="hljs-comment">// called from both the top- and bottom-half.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartstart</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(uart_tx_w == uart_tx_r)&#123;<br>      <span class="hljs-comment">// transmit buffer is empty.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// the UART transmit holding register is full,</span><br>      <span class="hljs-comment">// so we cannot give it another byte.</span><br>      <span class="hljs-comment">// it will interrupt when it&#x27;s ready for a new byte.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];<br>    uart_tx_r += <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// maybe uartputc() is waiting for space in the buffer.</span><br>    wakeup(&amp;uart_tx_r);<br>    <br>    WriteReg(THR, c);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符的输入"><a href="#字符的输入" class="headerlink" title="字符的输入"></a>字符的输入</h2><p>当用户在键盘上输入字符时，UART 会产生一个中断，PLIC 接收到中断后会路由到特定的 CPU 核，如果该核心设置了 SIE 的 E 位（外部中断位），硬件执行以下操作：</p><ol><li>清除 SIE 寄存器的相应 bit 以关闭中断；</li><li>设置 SEPC 为当前程序计数器；</li><li>保存当前的 mode；</li><li>将 mode 设置为 Supervisor mode；</li><li>将 PC 设置为 STVEC 的值</li></ol><p>接下来发生的事和 trap 一致，即保存现场并进入 <code>trap.c</code> 的 <code>usertrap</code> 函数，然后判断是否为设备中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-comment">// ok</span><br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>查看 <code>devintr</code> 可知，内核通过查看 scause 寄存器判断是否为外部中断，然后通过 <code>plic_claim</code> 获取中断；对于键盘输入的中断而言，最终会调用中断处理程序 <code>uartintr</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/trap.c</span><br><span class="hljs-comment">// check if it&#x27;s an external interrupt or software interrupt,</span><br><span class="hljs-comment">// and handle it.</span><br><span class="hljs-comment">// returns 2 if timer interrupt,</span><br><span class="hljs-comment">// 1 if other device,</span><br><span class="hljs-comment">// 0 if not recognized.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">devintr</span><span class="hljs-params">()</span><br>&#123;<br>  uint64 scause = r_scause();<br><br>  <span class="hljs-keyword">if</span>((scause &amp; <span class="hljs-number">0x8000000000000000</span>L) &amp;&amp;<br>     (scause &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">9</span>)&#123;<br>    <span class="hljs-comment">// this is a supervisor external interrupt, via PLIC.</span><br><br>    <span class="hljs-comment">// irq indicates which device interrupted.</span><br>    <span class="hljs-type">int</span> irq = plic_claim();<br><br>    <span class="hljs-keyword">if</span>(irq == UART0_IRQ)&#123;<br>      uartintr();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq == VIRTIO0_IRQ)&#123;<br>      virtio_disk_intr();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);<br>    &#125;<br><br>    <span class="hljs-comment">// the PLIC allows each device to raise at most one</span><br>    <span class="hljs-comment">// interrupt at a time; tell the PLIC the device is</span><br>    <span class="hljs-comment">// now allowed to interrupt again.</span><br>    <span class="hljs-keyword">if</span>(irq)<br>      plic_complete(irq);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scause == <span class="hljs-number">0x8000000000000001</span>L)&#123;<br>    <span class="hljs-comment">// software interrupt from a machine-mode timer interrupt,</span><br>    <span class="hljs-comment">// forwarded by timervec in kernelvec.S.</span><br><br>    <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;<br>      clockintr();<br>    &#125;<br>    <br>    <span class="hljs-comment">// acknowledge the software interrupt by clearing</span><br>    <span class="hljs-comment">// the SSIP bit in sip.</span><br>    w_sip(r_sip() &amp; ~<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uartintr</code> 是 UART 驱动的 bottom 部分，用来处理键盘输入和收到字符造成的中断。这个函数先是通过 <code>uartgetc</code> 读取字符，然后通过 <code>consoleintr</code>（即 CONSOLE 的中断处理程序）把字符显示到 CONSOLE 中。这里并不是中断的嵌套，因为不涉及硬件状态的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/uart.c</span><br><span class="hljs-comment">// handle a uart interrupt, raised because input has</span><br><span class="hljs-comment">// arrived, or the uart is ready for more output, or</span><br><span class="hljs-comment">// both. called from devintr().</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartintr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// read and process incoming characters.</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">int</span> c = uartgetc();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    consoleintr(c);<br>  &#125;<br><br>  <span class="hljs-comment">// send buffered characters.</span><br>  acquire(&amp;uart_tx_lock);<br>  uartstart();<br>  release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>consoleintr</code> 中，CONSOLE 会对特殊字符（如 BackSpace，Ctrl+P等）进行处理，然后通过 <code>consputc</code> 把字符显示到屏幕上；如果读入到换行符，那么还会唤醒等待读入的 <code>consoleread</code>，把内容返回给 shell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/console.c</span><br><span class="hljs-comment">// the console input interrupt handler.</span><br><span class="hljs-comment">// uartintr() calls this for input character.</span><br><span class="hljs-comment">// do erase/kill processing, append to cons.buf,</span><br><span class="hljs-comment">// wake up consoleread() if a whole line has arrived.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">consoleintr</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  acquire(&amp;cons.lock);<br><br>  <span class="hljs-keyword">switch</span>(c)&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;P&#x27;</span>)</span>:  <span class="hljs-comment">// Print process list.</span><br>    <span class="hljs-title function_">procdump</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;U&#x27;</span>)</span>:  <span class="hljs-comment">// Kill line.</span><br>    <span class="hljs-title function_">while</span><span class="hljs-params">(cons.e != cons.w &amp;&amp;</span><br><span class="hljs-params">          cons.buf[(cons.e<span class="hljs-number">-1</span>) % INPUT_BUF_SIZE] != <span class="hljs-string">&#x27;\n&#x27;</span>)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;H&#x27;</span>)</span>: <span class="hljs-comment">// Backspace</span><br>  <span class="hljs-keyword">case</span> &#x27;\x7f&#x27;: <span class="hljs-comment">// Delete key</span><br>    <span class="hljs-title function_">if</span><span class="hljs-params">(cons.e != cons.w)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;<br>      c = (c == <span class="hljs-string">&#x27;\r&#x27;</span>) ? <span class="hljs-string">&#x27;\n&#x27;</span> : c;<br><br>      <span class="hljs-comment">// echo back to the user.</span><br>      consputc(c);<br><br>      <span class="hljs-comment">// store for consumption by consoleread().</span><br>      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;<br><br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == C(<span class="hljs-string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;<br>        <span class="hljs-comment">// wake up consoleread() if a whole line (or end-of-file)</span><br>        <span class="hljs-comment">// has arrived.</span><br>        cons.w = cons.e;<br>        wakeup(&amp;cons.r);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <br>  release(&amp;cons.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么拼图的最后一块就是 <code>consputc</code> 了，这个函数通过 <code>uartputc_sync</code> 来向屏幕输出字符，和 <code>consolewrite</code> 所使用的 <code>uartputc</code> 有所不同，同步版的 <code>uartputc_sync</code> 会一直自旋直到能够发送字符为止，而异步版的 <code>uartputc</code> 调用了 <code>uartstart</code>，在发现不能发送字符时会直接返回，后续能够继续发送字符时 UART 发出中断，<code>uartintr</code> 会重新调用 <code>uartstart</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel/console.c</span><br><span class="hljs-comment">// send one character to the uart.</span><br><span class="hljs-comment">// called by printf(), and to echo input characters,</span><br><span class="hljs-comment">// but not from write().</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">consputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(c == BACKSPACE)&#123;<br>    <span class="hljs-comment">// if the user typed backspace, overwrite with a space.</span><br>    uartputc_sync(<span class="hljs-string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="hljs-string">&#x27; &#x27;</span>); uartputc_sync(<span class="hljs-string">&#x27;\b&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    uartputc_sync(c);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// kernel/uart.c</span><br><span class="hljs-comment">// alternate version of uartputc() that doesn&#x27;t </span><br><span class="hljs-comment">// use interrupts, for use by kernel printf() and</span><br><span class="hljs-comment">// to echo characters. it spins waiting for the uart&#x27;s</span><br><span class="hljs-comment">// output register to be empty.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartputc_sync</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  push_off();<br><br>  <span class="hljs-keyword">if</span>(panicked)&#123;<br>    <span class="hljs-keyword">for</span>(;;)<br>      ;<br>  &#125;<br><br>  <span class="hljs-comment">// wait for Transmit Holding Empty to be set in LSR.</span><br>  <span class="hljs-keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)<br>    ;<br>  WriteReg(THR, c);<br><br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2021年ICPC国际大学生程序设计竞赛-C</title>
    <link href="/2022/06/10/problem1/"/>
    <url>/2022/06/10/problem1/</url>
    
    <content type="html"><![CDATA[<p>原题链接：<a href="https://ac.nowcoder.com/acm/contest/35232/C">https://ac.nowcoder.com/acm/contest/35232/C</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在区间 $[l,r]$ 内任意选取 $k$ 个数求最大公因数，问有多少种可能的结果。</p><ul><li>$1\leq l\leq r\leq 10^{12},$</li><li>$2\leq k\leq r-l+1$</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="数学本质"><a href="#数学本质" class="headerlink" title="数学本质"></a>数学本质</h2><p>首先，显然有：</p><ul><li>$(b-a)$ 是 $gcd(a,b)$ 的倍数。</li></ul><p>由此可得：</p><ul><li>$gcd(a,a+1)=1.$</li></ul><p>于是有：</p><ul><li>$gcd(ax,(a+1)x)=x.$</li></ul><p>所以最紧凑的 $k$ 个以 $x$ 为最大公因数的数必然是：</p><ul><li>$ax,(a+1)x,…,(a+k-1)x.$</li></ul><p>所以 $[l,r]$ 中能选出 $k$ 个以 $x$ 为最大公因数的数等价于：</p><ul><li>设 $t$ 是不小于 $l$ 的最小的 $x$ 的倍数，则 $t+(k-1)x\leq r.$</li></ul><p>整理一下可以得到，题意是求满足</p><script type="math/tex; mode=display">kx+\lfloor\frac{l-1}{x}\rfloor x\leq r</script><p>的 $x$ 的个数。</p><h2 id="计数方法"><a href="#计数方法" class="headerlink" title="计数方法"></a>计数方法</h2><p>看了很多人ac的代码是用二分来做的，即认为 $x$ 成立则 $x-1$ 一定成立。这显然是错误的，对于数据<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">24</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><br>来说，$6$ 成立但是 $5$ 不成立，用二分的代码跑出来的答案都是 $6$ 种，实际上答案只有 $5$ 种。</p><p>上式的关键是 $\lfloor\frac{l-1}{x}\rfloor$ 的计算。</p><p>当 $x\geq l$ 时，$\lfloor\frac{l-1}{x}\rfloor=0$，这部分的答案是 $max{\frac{r}{k}-l+1,0}.$</p><p>当 $x&lt;l$ 时，可以对 $\lfloor\frac{l-1}{x}\rfloor$ 的取值分段讨论：</p><ul><li>$x\in (\frac{l-1}{2},l-1],\lfloor\frac{l-1}{x}\rfloor=1;$</li><li>$x\in (\frac{l-1}{3},\frac{l-1}{2}],\lfloor\frac{l-1}{x}\rfloor=2;$</li><li>$x\in (\frac{l-1}{4},\frac{l-1}{3}],\lfloor\frac{l-1}{x}\rfloor=3;$</li><li>…</li></ul><p>正解是对上面每一段单独解不等式并把答案累加。</p><p>这样做的正确性是显然的，问题在于 $l$ 的值很大时，这样分段是否会超时。实际上，这样分段的时间复杂度是 $O(\sqrt{l})$，对于本题来说是不会超时的。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> l,r,k;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k;<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-built_in">std</span>::max(r/k-l+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<br>    l--;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>;i &lt;= l;)&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = l/(l/i);<br>        ans+=<span class="hljs-built_in">std</span>::max(<span class="hljs-built_in">std</span>::min(r/(k+l/t),t)-i+<span class="hljs-number">1</span>,<span class="hljs-number">0ll</span>);<br>        i = t + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git三种协议的代理配置</title>
    <link href="/2022/05/11/git_proxy/"/>
    <url>/2022/05/11/git_proxy/</url>
    
    <content type="html"><![CDATA[<p>最近在安装 MIT6.S081 的实验环境时又受到了国内网络的制裁，这里浅浅记录一下如何配置 git 的代理。</p><p>所用的环境是 WSL2 的 Ubuntu-20.04.4 LTS，SSR 运行在 windows 的 <code>12345</code> 端口，打开了允许来自局域网的连接。</p><h1 id="获取windows的ip"><a href="#获取windows的ip" class="headerlink" title="获取windows的ip"></a>获取windows的ip</h1><p>众所周知，WSL2 会把 windows 的虚拟网卡 vEthernet 作为默认网关，所以我们需要的代理地址就是 <code>ip:12345</code>，其中 ip 是 vEthernet 的地址。</p><p>然而 vEthernet 和 WSL2 的 ip 每次重启都会变，所以写一个 <code>gethost.sh</code> 来获取 vEthernet 的 ip：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br>ip route | grep default | awk `&#123;<span class="hljs-built_in">print</span> <span class="hljs-variable">$3</span>&#125;`<br></code></pre></td></tr></table></figure><p>然后 <code>chmod +x gethost.sh</code> 添加执行权限即可。</p><h1 id="配置-git-代理"><a href="#配置-git-代理" class="headerlink" title="配置 git 代理"></a>配置 git 代理</h1><h2 id="https"><a href="#https" class="headerlink" title="https://"></a>https://</h2><p>对于形如 <code>git clone https://path/to/repository.git</code> 的命令，只需要</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> http_proxy=http://$(/path/to/gethost.sh):12345<br>$ <span class="hljs-built_in">export</span> https_proxy=http://$(/path/to/gethost.sh):12345<br></code></pre></td></tr></table></figure><p>设置整个系统的全局代理即可。</p><h2 id="git"><a href="#git" class="headerlink" title="git@"></a>git@</h2><p>形如 <code>git clone git@github.com:path/to/repository.git</code> 的命令，本质上用了 ssh 来和服务器通信，所以要配置 ssh 代理。配置文件在 <code>~/.ssh/config</code>：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">Host github.com<br>    HostName github.com<br>    User git<br>    IdentityFile ~<span class="hljs-regexp">/.ssh/gi</span>thub<br>    ProxyCommand <span class="hljs-keyword">connect</span> -H &lt;hostip&gt;:<span class="hljs-number">12345</span> %h %p<br></code></pre></td></tr></table></figure><p>其中 <code>ProxyCommand</code> 这一项就是关于 ssh 代理的配置。<code>connect -H &lt;hostip&gt;:12345 %h %p</code> 是 ssh 连接时执行的命令。</p><blockquote><p>connect 可能需要通过 <code>apt install connect-proxy</code> 安装。<code>-H</code> 指明通过 http 协议进行连接，<code>&lt;hostip&gt;</code> 需要改成 vEthernet 的 ip，<code>%h %p</code> 是 ssh 命令自己传入的参数，即服务器的 hostname 和 port。</p></blockquote><p>上面的命令唯一需要自己改写的地方就是 <code>&lt;hostip&gt;</code> ，可以在 <code>~/.bashrc</code> 中写一段脚本，通过 <code>gethost.sh</code> 实现自动替换。</p><h2 id="git-1"><a href="#git-1" class="headerlink" title="git://"></a>git://</h2><p>形如 <code>git clone git://path/to/repository</code> 的命令配置代理较为特殊。</p><p>首先要写一个执行代理命令的脚本，比如叫 <code>gitproxy.sh</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br>host=$(/path/to/getHost.sh)<br>connect -H <span class="hljs-variable">$host</span>:12345 <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><p>用 <code>chmod +x gitproxy.sh</code> 添加执行权限。然后配置:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> core<span class="hljs-selector-class">.gitproxy</span> <span class="hljs-string">&quot;/path/to/gitproxy.sh&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>“$@” 在 sh 中表示脚本被执行时传入的全部参数，在这里的作用等同于 ssh 配置命令中的 <code>%h %p</code>。</p></blockquote><p>至此，三种协议的 git 代理配置都已经列举完毕。</p>]]></content>
    
    
    <categories>
      
      <category>开发实践</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2022/03/22/factory_pattern/"/>
    <url>/2022/03/22/factory_pattern/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式概述"><a href="#工厂模式概述" class="headerlink" title="工厂模式概述"></a>工厂模式概述</h1><p>工厂模式是一种用于创建对象的设计模式，其核心在于把获得某种对象的过程从程序中解耦出来，成为一个单独的模块。</p><p>这样做为什么是必要的呢？在一些时候，获得对象只需要一行简单的 <code>new</code> 语句，此时确实没有将其封装的必要；但在实际场景中，创建一个对象的过程也许会更为复杂。</p><p>举个例子，假设 A 对象的创建依赖 B 对象和 C 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br><span class="hljs-comment">// do something to b</span><br><span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br><span class="hljs-comment">// do something to c</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>(b,c);<br></code></pre></td></tr></table></figure><p>假设有十个模块都用这种方式创建 A 对象，那么如果某天想把 A 对象的创建改为依赖一个 D 对象，我们就只能把这十个模块手动改一遍。</p><p>如果我们用了工厂模式的设计思想，把上面的过程封装成到一个工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span>&#123;<br>    <span class="hljs-keyword">public</span> A <span class="hljs-title function_">CreateA</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        <span class="hljs-comment">// do something to b</span><br>        <span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>        <span class="hljs-comment">// do something to c</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>(b,c);<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而其他模块都通过工厂类来获取A对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Factory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>();<br>A = f.CreateA();<br></code></pre></td></tr></table></figure><p>那么后续A的创建过程被修改时，我们只要修改<code>Factory</code>类就可以了。</p><h1 id="工厂模式具体实现"><a href="#工厂模式具体实现" class="headerlink" title="工厂模式具体实现"></a>工厂模式具体实现</h1><p>工厂模式的思想我们已经清楚了，在实践中，工厂模式大体上有三种实现形式，即：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>假设有两个类Phone和Tablet，都继承自抽象类Device，我们来考察不同的工厂模式如何创建所需的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Device</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Device</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A phone is working&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tablet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Device</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A tablet is working&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>这种实现方式定义一个工厂类，在这个类中实现所有对象的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    <span class="hljs-keyword">public</span> Device <span class="hljs-title function_">createDevice</span><span class="hljs-params">(<span class="hljs-type">int</span> deviceType)</span>&#123;<br>        <span class="hljs-keyword">if</span> (deviceType == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deviceType == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tablet</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写的优点在于不必在原有基础上添加过多的代码，而且便于控制创建不同对象的逻辑。比如游戏中敌人被击败时掉落道具的代码，创建何种道具对象的逻辑可能十分复杂，就适合采用此种方式。</p><p>而此方法的缺点是，后续增加对象时，不得不修改现有的代码，系统的可扩展性一般。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>此方法定义一个创建对象的抽象接口，用不同的子类实现创建具体对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    Device <span class="hljs-title function_">createDevice</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Device <span class="hljs-title function_">createDevice</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TabletFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Device <span class="hljs-title function_">createDevice</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tablet</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的优点是后续增加对象时，不需要修改已有代码，只需增加新的子类，整个项目架构十分清晰，可扩展性高。</p><p>缺点也是明显的，即代码量大，而且本身无法实现不同对象创建的逻辑，只关注于对象的创建过程本身。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>上面提到的工厂方法模式，其工厂只负责创建一种对象，而此种模式下一种工厂负责创建一类对象。</p><p>在上面举的例子中，我们把Phone和Tablet改为抽象类，并为它们添加子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Device</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaweiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A HuaweiPhone is working&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaomiPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A XiaomiPhone is working&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tablet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Device</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaweiTablet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Tablet</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A HuaweiPhone is working&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaomiTablet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Tablet</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A XiaomiTablet is working&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于四种对象，如果用工厂方法模式，需要四种工厂。但这四种对象继承自两种抽象类，这意味着我们其实可以用两种工厂完成创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    Phone <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span>;<br>    Tablet <span class="hljs-title function_">createTablet</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuaweiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Phone <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaweiPhone</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Tablet <span class="hljs-title function_">createTablet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuaweiTablet</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaomiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeviceFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Phone <span class="hljs-title function_">createPhone</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaomiPhone</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Tablet <span class="hljs-title function_">createTablet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaomiTablet</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是所谓抽象工厂模式，其本质是对工厂进行了一层抽象：把原来所需的四种工厂，根据创建对象的某些共性抽象为两种。此方法适用于对象有较多继承关系的场景，可以减少工厂方法模式需要的工厂数量。缺点是扩展性弱，例如后续增加一个earphone抽象类，就需要修改所有工厂类。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂模式体现了面向对象中“各司其职”的思想，是为了把复杂的业务逻辑划分到不同模块，降低耦合程度，以提高代码的复用性，便于开发和后期维护。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
